<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>COSMOGONIE & COSMOLOGIE</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <script src="libs/aframe-master.min.js"></script>
    <script src="libs/aframe-ar.js"></script>
    <script src="libs/AR.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
    <script src="libs/gesture-detector.js"></script>
</head>
<body>
    <!-- Schermata iniziale per avviare l'interazione -->
    <div id="start-screen" style="
        position: absolute; 
        top: 50%; 
        left: 50%; 
        transform: translate(-50%, -50%); 
        z-index: 10; 
        background: #000; 
        color: #fff; 
        padding: 20px; 
        text-align: center; 
        font-family: Arial, sans-serif; 
        cursor: pointer;">
        <h1>Tocca per iniziare</h1>
        <p>Consenti al browser di riprodurre audio e accedere alla fotocamera.</p>
    </div>

    <!-- Scena A-Frame nascosta inizialmente -->
    <a-scene 
        gesture-detector 
        embedded 
        arjs="sourceType: webcam; detectionMode: mono_and_matrix; matrixCodeType: 3x3;" 
        renderer="precision: medium;" 
        style="display: none;">
        
        <a-assets>
            <a-asset-item id="model" src="models/yale_tablet/scene.gltf"></a-asset-item>
            <audio id="background-audio" src="models/yale_tablet/background.wav" playsinline></audio>
        </a-assets>

        <a-marker type="barcode" value="30">
            <a-entity 
                gltf-model="#model"
                scale="0.05 0.05 0.05"
                rotation="-90 180 180"
                class="clickable"
                interaction-handler></a-entity>
        </a-marker>

        <a-sound
            id="audio-player"
            src="#background-audio"
            autoplay="true"
            position="0 0 0">
        </a-sound>

        <a-entity camera></a-entity>
    </a-scene>

    <script>
        // Avvio interazione utente per iOS e altri dispositivi con restrizioni autoplay
        document.getElementById('start-screen').addEventListener('click', function () {
            const audio = document.querySelector('#background-audio');
            const scene = document.querySelector('a-scene');
            
            // Tentativo di riprodurre l'audio
            audio.play().then(() => {
                console.log('Audio avviato con successo.');
            }).catch((error) => {
                console.warn('Autoplay non consentito. Richiesta interazione manuale.');
            });

            // Mostra la scena e nasconde la schermata iniziale
            scene.style.display = 'block';
            document.getElementById('start-screen').style.display = 'none';
        });

        // Componente per gestire interazioni touch, mouse e orientamento dispositivo
        AFRAME.registerComponent('interaction-handler', {
            init: function () {
                // Mouse interaction setup
                this.isMouseDown = false;
                this.previousMousePosition = { x: 0, y: 0 };
                this.zoomFactor = 0.1;

                // Touch interaction setup
                this.previousTouch = null;
                this.touchSensitivity = 0.01;

                // Device orientation setup
                this.rotationSpeed = 0.0002;
                this.deviceThreshold = 60;

                const canvas = this.el.sceneEl.canvas;
                canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                canvas.addEventListener('wheel', this.onMouseWheel.bind(this));

                this.el.sceneEl.addEventListener('touchstart', this.onTouchStart.bind(this));
                this.el.sceneEl.addEventListener('touchmove', this.onTouchMove.bind(this));
                this.el.sceneEl.addEventListener('touchend', this.onTouchEnd.bind(this));

                window.addEventListener('deviceorientation', this.onDeviceOrientation.bind(this));
            },

            // Mouse event handlers
            onMouseDown: function (event) {
                this.isMouseDown = true;
                this.previousMousePosition.x = event.clientX;
                this.previousMousePosition.y = event.clientY;
            },

            onMouseUp: function () {
                this.isMouseDown = false;
            },

            onMouseMove: function (event) {
                if (!this.isMouseDown) return;

                const deltaX = event.clientX - this.previousMousePosition.x;
                const deltaY = event.clientY - this.previousMousePosition.y;

                const object3D = this.el.object3D;

                if (event.buttons === 1) { // Tasto sinistro: rotazione
                    object3D.rotation.y += deltaX * 0.005;
                    object3D.rotation.x += deltaY * 0.005;
                } else if (event.buttons === 2) { // Tasto destro: traslazione
                    object3D.position.x += deltaX * 0.001;
                    object3D.position.y -= deltaY * 0.001;
                }

                this.previousMousePosition.x = event.clientX;
                this.previousMousePosition.y = event.clientY;
            },

            onMouseWheel: function (event) {
                const object3D = this.el.object3D;
                object3D.scale.multiplyScalar(1 - Math.sign(event.deltaY) * this.zoomFactor);
            },

            // Touch event handlers
            onTouchStart: function (event) {
                if (event.touches.length === 1) {
                    this.previousTouch = {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY,
                    };
                } else if (event.touches.length === 2) {
                    this.previousTouch = this.getMidpoint(event.touches);
                    this.initialDistance = this.getDistance(event.touches);
                }
            },

            onTouchMove: function (event) {
                const object3D = this.el.object3D;

                if (event.touches.length === 1) {
                    // Rotazione con un dito
                    const currentTouch = {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY,
                    };
                    const deltaX = (currentTouch.x - this.previousTouch.x) * this.touchSensitivity;
                    const deltaY = (currentTouch.y - this.previousTouch.y) * this.touchSensitivity;

                    object3D.rotation.y += deltaX;
                    object3D.rotation.x += deltaY;

                    this.previousTouch = currentTouch;
                } else if (event.touches.length === 2) {
                    // Traslazione e zoom con due dita
                    const currentMidpoint = this.getMidpoint(event.touches);
                    const currentDistance = this.getDistance(event.touches);

                    // Calcolare la differenza rispetto al punto precedente
                    const deltaX = (currentMidpoint.x - this.previousTouch.x) * this.touchSensitivity;
                    const deltaY = (currentMidpoint.y - this.previousTouch.y) * this.touchSensitivity;

                    object3D.position.x += deltaX;   // Movimento laterale
                    object3D.position.y -= deltaY;   // Movimento alto-basso
                    object3D.scale.multiplyScalar(currentDistance / this.initialDistance);

                    // Aggiorna riferimenti per la prossima mossa
                    this.previousTouch = currentMidpoint;
                    this.initialDistance = currentDistance;
                }
            },

            onTouchEnd: function () {
                this.previousTouch = null;
                this.initialDistance = null;
            },

            // Utility methods for touch
            getMidpoint: function (touches) {
                return {
                    x: (touches[0].clientX + touches[1].clientX) / 2,
                    y: (touches[0].clientY + touches[1].clientY) / 2,
                };
            },

            getDistance: function (touches) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            },

            // Device orientation handler
            onDeviceOrientation: function (event) {
                const object3D = this.el.object3D;
                const gamma = event.gamma; // Tilt left-right
                const beta = event.beta;   // Tilt front-back

                if (Math.abs(gamma) > this.deviceThreshold) {
                    object3D.rotation.y -= gamma * this.rotationSpeed;
                }

                // Disabilitato il controllo verticale per evitare problemi di usabilitÃ 
                // if (Math.abs(beta) > this.deviceThreshold) {
                //     object3D.rotation.x += beta * this.rotationSpeed;
                // }
            },
        });
    </script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</body>
</html>
