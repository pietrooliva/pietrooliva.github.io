<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>COSMOGONIE & COSMOLOGIE</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <script src="libs/aframe-master.min.js"></script>
    <script src="libs/aframe-ar.js"></script>
    <script src="libs/AR.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
    <script src="libs/gesture-detector.js"></script>
</head>
<body>
    <a-scene 
        gesture-detector 
        embedded 
        arjs="sourceType: webcam; detectionMode: mono_and_matrix; matrixCodeType: 3x3;" 
        renderer="precision: medium;">
        
        <a-assets>
            <a-asset-item id="model" src="models/yale_tablet/scene.gltf"></a-asset-item>
            <audio id="background-audio" src="models/yale_tablet/background.mp3"></audio>
        </a-assets>

        <a-marker type="barcode" value="30">
            <a-entity 
                gltf-model="#model"
                scale="0.05 0.05 0.05"
                rotation="-90 180 180"
                class="clickable"
                interaction-handler></a-entity>
        </a-marker>

        <a-entity camera></a-entity>
    </a-scene>

    <button id="audioButton" style="
        position: fixed; 
        bottom: 10px; 
        left: 10px; 
        padding: 10px 20px; 
        background: rgba(0, 0, 0, 0.8); 
        color: white; 
        border: none; 
        border-radius: 5px; 
        font-size: 16px;">
        Play Audio
    </button>

    <script>
        const audioElement = document.getElementById('background-audio');
        const audioButton = document.getElementById('audioButton');

        // Play audio when the button is clicked
        audioButton.addEventListener('click', () => {
            if (audioElement.paused) {
                audioElement.play();
                audioButton.textContent = "Pause Audio";
            } else {
                audioElement.pause();
                audioButton.textContent = "Play Audio";
            }
        });

        // Interaction handler for gestures (mouse + touch)
        AFRAME.registerComponent('interaction-handler', {
            init: function () {
                // Mouse interaction
                this.isMouseDown = false;
                this.previousMousePosition = { x: 0, y: 0 };
                this.zoomFactor = 0.1;

                // Touch interaction
                this.previousTouch = null;
                this.initialDistance = null;
                this.touchSensitivity = 0.01;

                const canvas = this.el.sceneEl.canvas;

                // Mouse events
                canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                canvas.addEventListener('wheel', this.onMouseWheel.bind(this));

                // Touch events
                this.el.sceneEl.addEventListener('touchstart', this.onTouchStart.bind(this));
                this.el.sceneEl.addEventListener('touchmove', this.onTouchMove.bind(this));
                this.el.sceneEl.addEventListener('touchend', this.onTouchEnd.bind(this));
            },

            // Mouse event handlers
            onMouseDown: function (event) {
                this.isMouseDown = true;
                this.previousMousePosition.x = event.clientX;
                this.previousMousePosition.y = event.clientY;
            },

            onMouseUp: function () {
                this.isMouseDown = false;
            },

            onMouseMove: function (event) {
                if (!this.isMouseDown) return;

                const deltaX = event.clientX - this.previousMousePosition.x;
                const deltaY = event.clientY - this.previousMousePosition.y;

                const object3D = this.el.object3D;

                if (event.buttons === 1) { // Left button: rotation
                    object3D.rotation.y += deltaX * 0.005;
                    object3D.rotation.x += deltaY * 0.005;
                } else if (event.buttons === 2) { // Right button: translation
                    object3D.position.x += deltaX * 0.001;
                    object3D.position.y -= deltaY * 0.001;
                }

                this.previousMousePosition.x = event.clientX;
                this.previousMousePosition.y = event.clientY;
            },

            onMouseWheel: function (event) {
                const object3D = this.el.object3D;
                object3D.scale.multiplyScalar(1 - Math.sign(event.deltaY) * this.zoomFactor);
            },

            // Touch event handlers
            onTouchStart: function (event) {
                if (event.touches.length === 1) {
                    this.previousTouch = {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY,
                    };
                } else if (event.touches.length === 2) {
                    this.previousTouch = this.getMidpoint(event.touches);
                    this.initialDistance = this.getDistance(event.touches);
                }
            },

            onTouchMove: function (event) {
                const object3D = this.el.object3D;

                if (event.touches.length === 1) {
                    const currentTouch = {
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY,
                    };
                    const deltaX = (currentTouch.x - this.previousTouch.x) * this.touchSensitivity;
                    const deltaY = (currentTouch.y - this.previousTouch.y) * this.touchSensitivity;

                    object3D.rotation.y += deltaX;
                    object3D.rotation.x += deltaY;

                    this.previousTouch = currentTouch;
                } else if (event.touches.length === 2) {
                    const currentMidpoint = this.getMidpoint(event.touches);
                    const currentDistance = this.getDistance(event.touches);

                    const deltaX = (currentMidpoint.x - this.previousTouch.x) * this.touchSensitivity;
                    const deltaY = (currentMidpoint.y - this.previousTouch.y) * this.touchSensitivity;

                    object3D.position.x += deltaX;
                    object3D.position.y -= deltaY;
                    object3D.scale.multiplyScalar(currentDistance / this.initialDistance);

                    this.previousTouch = currentMidpoint;
                    this.initialDistance = currentDistance;
                }
            },

            onTouchEnd: function () {
                this.previousTouch = null;
                this.initialDistance = null;
            },

            // Utility methods
            getMidpoint: function (touches) {
                return {
                    x: (touches[0].clientX + touches[1].clientX) / 2,
                    y: (touches[0].clientY + touches[1].clientY) / 2,
                };
            },

            getDistance: function (touches) {
                const dx = touches[0].clientX - touches[1].clientX;
                const dy = touches[0].clientY - touches[1].clientY;
                return Math.sqrt(dx * dx + dy * dy);
            },
        });
    </script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</body>
</html>
