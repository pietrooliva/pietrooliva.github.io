<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>AR Model Interaction</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <script src="libs/aframe-master.min.js"></script>
    <script src="libs/aframe-ar.js"></script>
    <script src="libs/AR.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
    <script src="libs/gesture-detector.js"></script>
</head>
<body>
    <a-scene 
        gesture-detector 
        embedded 
        arjs="sourceType: webcam; detectionMode: mono_and_matrix; matrixCodeType: 3x3;" 
        renderer="precision: medium;">
        
        <a-assets>
            <a-asset-item id="model" src="models/yale_tablet/scene.gltf"></a-asset-item>
        </a-assets>

        <a-marker type="barcode" value="30">
            <a-entity 
                gltf-model="#model"
                scale="0.05 0.05 0.05"
                rotation="-90 180 180"
                class="clickable"
                interaction-handler></a-entity>
        </a-marker>

        <a-entity camera></a-entity>
    </a-scene>

    <script>
        // Componente per gestire interazioni touch, mouse e orientamento dispositivo
        AFRAME.registerComponent('interaction-handler', {
            init: function () {
                // Mouse interaction setup
                this.isMouseDown = false;
                this.previousMousePosition = { x: 0, y: 0 };
                this.zoomFactor = 0.1;

                // Touch interaction setup
                this.previousTouch = { x: 0, y: 0 };
                this.touchSensitivity = 0.005;

                // Device orientation setup
                this.rotationSpeed = 0.0002;
                this.deviceThreshold = 15;

                const canvas = this.el.sceneEl.canvas;
                canvas.addEventListener('mousedown', this.onMouseDown.bind(this));
                canvas.addEventListener('mouseup', this.onMouseUp.bind(this));
                canvas.addEventListener('mousemove', this.onMouseMove.bind(this));
                canvas.addEventListener('wheel', this.onMouseWheel.bind(this));

                this.el.sceneEl.addEventListener('gesturemove', this.onGestureMove.bind(this));
                window.addEventListener('deviceorientation', this.onDeviceOrientation.bind(this));
            },

            // Mouse event handlers
            onMouseDown: function (event) {
                this.isMouseDown = true;
                this.previousMousePosition.x = event.clientX;
                this.previousMousePosition.y = event.clientY;
            },

            onMouseUp: function () {
                this.isMouseDown = false;
            },

            onMouseMove: function (event) {
                if (!this.isMouseDown) return;

                const deltaX = event.clientX - this.previousMousePosition.x;
                const deltaY = event.clientY - this.previousMousePosition.y;

                const object3D = this.el.object3D;

                if (event.buttons === 1) { // Tasto sinistro: rotazione
                    object3D.rotation.y += deltaX * 0.005;
                    object3D.rotation.x += deltaY * 0.005;
                } else if (event.buttons === 2) { // Tasto destro: traslazione
                    object3D.position.x += deltaX * 0.001;
                    object3D.position.y -= deltaY * 0.001;
                }

                this.previousMousePosition.x = event.clientX;
                this.previousMousePosition.y = event.clientY;
            },

            onMouseWheel: function (event) {
                const object3D = this.el.object3D;
                object3D.scale.multiplyScalar(1 - Math.sign(event.deltaY) * this.zoomFactor);
            },

            // Touch gesture handlers
            onGestureMove: function (event) {
                const { detail } = event;
                const object3D = this.el.object3D;

                if (detail.type === 'translate' && detail.numFingers === 2) {
                    const deltaX = detail.deltaPosition.x * this.touchSensitivity;
                    const deltaY = detail.deltaPosition.y * this.touchSensitivity;

                    object3D.position.x += deltaX;
                    object3D.position.y -= deltaY;
                } else if (detail.type === 'rotate' && detail.numFingers === 1) {
                    const deltaX = detail.deltaPosition.x * this.touchSensitivity;
                    const deltaY = detail.deltaPosition.y * this.touchSensitivity;

                    object3D.rotation.y += deltaX;
                    object3D.rotation.x += deltaY;
                } else if (detail.type === 'scale') {
                    const scaleDelta = detail.scaleChange;
                    object3D.scale.multiplyScalar(scaleDelta);
                }
            },

            // Device orientation handler
            onDeviceOrientation: function (event) {
                const object3D = this.el.object3D;
                const gamma = event.gamma; // Tilt left-right
                const beta = event.beta;   // Tilt front-back

                if (Math.abs(gamma) > this.deviceThreshold) {
                    object3D.rotation.y += gamma * this.rotationSpeed;
                }

                if (Math.abs(beta) > this.deviceThreshold) {
                    object3D.rotation.x += beta * this.rotationSpeed;
                }
            }
        });
    </script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</body>
</html>
