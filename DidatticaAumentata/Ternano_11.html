<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="utf-8" />
    <title>Té e Tisane | N.11</title>

    <!-- Viewport: evita lo “zoom strano” iniziale e copre safe-area iOS -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no" />

    <!-- Librerie A-Frame / AR.js / Extras / Gesture -->
    <script src="libs/aframe-master.min.js"></script>
    <script src="libs/aframe-ar.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
    <script src="libs/gesture-detector.js"></script>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: #000;
        touch-action: none;
      }

      /* A-Frame full-screen robusto (risolve canvas “a metà”) */
      a-scene {
        position: fixed !important;
        inset: 0 !important;
        width: 100% !important;
        height: 100% !important;
      }
      a-scene canvas {
        width: 100% !important;
        height: 100% !important;
        display: block;
      }

      /* Splash permessi sensori */
      #splash {
        display: flex;
        align-items: center;
        justify-content: center;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.92);
        color: #fff;
        text-align: center;
        z-index: 9999;
        padding: 24px;
        box-sizing: border-box;
      }
      #splash h1 {
        font-size: 1.05rem;
        margin: 0 0 1rem 0;
        font-weight: 600;
        line-height: 1.25;
      }
      #allowButton {
        padding: 10px 18px;
        font-size: 16px;
        background: rgba(255, 255, 255, 0.12);
        color: #ffffff;
        border: 1px solid rgba(255, 255, 255, 0.45);
        border-radius: 10px;
        cursor: pointer;
        backdrop-filter: blur(6px);
      }

      /* Pulsanti UI */
      .ui-button {
        position: fixed;
        bottom: max(10px, env(safe-area-inset-bottom));
        padding: 10px 12px;
        font-size: 16px;
        width: auto;
        max-width: 42vw;
        min-width: 150px;
        background: rgba(0, 0, 0, 0.72);
        color: #ffffff;
        border: 1px solid rgba(255, 255, 255, 0.35);
        border-radius: 12px;
        cursor: pointer;
        z-index: 1000;
        user-select: none;
        -webkit-user-select: none;
        backdrop-filter: blur(6px);
      }
      #audioButton {
        left: max(10px, env(safe-area-inset-left));
      }
      #animationButton {
        right: max(10px, env(safe-area-inset-right));
      }
    </style>
  </head>

  <body>
    <!-- Splash per permessi sensori -->
    <div id="splash">
      <div>
        <h1>È necessario l'accesso ai sensori di movimento di questo dispositivo</h1>
        <button id="allowButton">Consentire</button>
      </div>
    </div>

    <!-- Scena AR -->
    <a-scene
      gesture-detector
      embedded
      arjs="trackingMethod: best; sourceType: webcam;"
      renderer="antialias: true; precision: high; physicallyCorrectLights: true; colorManagement: true;"
    >
      <a-assets>
        <a-asset-item id="model" src="models/ternano/scene.gltf"></a-asset-item>
        <audio id="background-audio" src="models/ternano/background.mp3" preload="auto"></audio>
      </a-assets>

      <!-- Luci (in AR spesso conviene non esagerare con intensità) -->
      <a-light type="ambient" color="#ffffff" intensity="1.2"></a-light>
      <a-light type="directional" color="#ffffff" intensity="1.6" position="5 3 1"></a-light>

      <!-- Modello 3D
           IMPORTANTISSIMO: non metterlo in 0 0 0 (stessa posizione della camera).
           In A-Frame la camera guarda verso -Z, quindi lo metto davanti: z negativo. -->
      <a-entity
        id="animatedModel"
        class="clickable"
        gltf-model="#model"
        position="0 0 -1.2"
        rotation="0 0 0"
        interaction-handler
      ></a-entity>

      <!-- Camera: in AR.js la posa viene gestita dal sistema -->
      <a-entity camera></a-entity>
    </a-scene>

    <!-- Pulsanti audio / animazione -->
    <button id="audioButton" class="ui-button">Riproduci Audio</button>
    <button id="animationButton" class="ui-button">Avvia Animazione</button>

    <script>
      const splash = document.getElementById("splash");
      const allowButton = document.getElementById("allowButton");
      const audioElement = document.getElementById("background-audio");
      const audioButton = document.getElementById("audioButton");
      const animationButton = document.getElementById("animationButton");
      const animatedModel = document.getElementById("animatedModel");

      let isAnimationActive = false;
      let isNativeAnimation = false;

      // Renderer tuning (safe-guard tra versioni)
      document.addEventListener("DOMContentLoaded", () => {
        const sceneEl = document.querySelector("a-scene");
        if (!sceneEl) return;

        sceneEl.addEventListener("rendererinitialized", () => {
          const renderer = sceneEl.renderer;
          if (!renderer || typeof THREE === "undefined") return;

          // Compat: THREE.MathUtils vs THREE.Math
          // (Se la tua build non espone queste proprietà, semplicemente ignora.)
          try {
            // In A-Frame moderne: colorManagement true già gestisce sRGB.
            // Ma se la tua build è più vecchia, queste aiutano.
            if ("outputEncoding" in renderer && THREE.sRGBEncoding) {
              renderer.outputEncoding = THREE.sRGBEncoding;
            }
            if ("toneMapping" in renderer && THREE.ACESFilmicToneMapping) {
              renderer.toneMapping = THREE.ACESFilmicToneMapping;
              renderer.toneMappingExposure = 0.9;
            }
          } catch (e) {}
        });
      });

      // Auto-fit iniziale robusto: centra il pivot e imposta una scala “ragionevole”
      // SENZA dipendere da camera pose AR (che può cambiare subito).
      animatedModel.addEventListener("model-loaded", () => {
        const obj = animatedModel.getObject3D("mesh");
        if (!obj || typeof THREE === "undefined") return;

        // 1) Animazioni glTF?
        if (obj.animations && obj.animations.length > 0) {
          isNativeAnimation = true;
        }

        // 2) Bounding box
        const box = new THREE.Box3().setFromObject(obj);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        // 3) Recente pivot: sposta il contenuto così che il centro geometrico stia nell'origine dell'entity
        obj.position.sub(center);

        // 4) Imposta una scala iniziale basata sulla dimensione del modello.
        //    Idea: voglio che la "massima dimensione" sia ~0.6 m nel mondo A-Frame.
        //    Se il glTF è enorme (es. unità in mm), lo riduco. Se è minuscolo, lo ingrandisco.
        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const targetMaxDim = 0.6; // metri A-Frame (tuning)
        let scale = targetMaxDim / maxDim;

        // Clamp per evitare valori assurdi
        const minScale = 0.005;
        const maxScale = 13;
        scale = Math.max(minScale, Math.min(maxScale, scale));

        animatedModel.object3D.scale.setScalar(scale);

        // 5) Se vuoi un leggero "allontanamento" ulteriore:
        // animatedModel.object3D.position.z = -1.4;
      });

      // Pulsante animazione
      animationButton.addEventListener("click", () => {
        if (isNativeAnimation) {
          toggleNativeAnimation();
        } else {
          toggleCustomRotation();
        }
      });

      function toggleNativeAnimation() {
        if (!isAnimationActive) {
          // aframe-extras: animation-mixer
          animatedModel.setAttribute("animation-mixer", "");
          animationButton.textContent = "Ferma Animazione";
        } else {
          animatedModel.removeAttribute("animation-mixer");
          animationButton.textContent = "Avvia Animazione";
        }
        isAnimationActive = !isAnimationActive;
      }

      function toggleCustomRotation() {
        if (!isAnimationActive) {
          animatedModel.setAttribute("constant-rotation", "speed: 30");
          animationButton.textContent = "Ferma Animazione";
        } else {
          animatedModel.removeAttribute("constant-rotation");
          animationButton.textContent = "Avvia Animazione";
        }
        isAnimationActive = !isAnimationActive;
      }

      // Pulsante audio
      audioButton.addEventListener("click", () => {
        if (audioElement.paused) {
          audioElement.play().catch(() => {
            // iOS a volte richiede un gesto utente: il click c'è già, ma evitiamo errori.
          });
          audioButton.textContent = "Interrompi Audio";
        } else {
          audioElement.pause();
          audioButton.textContent = "Riproduci Audio";
        }
      });

      // Permessi sensori (iOS)
      allowButton.addEventListener("click", async () => {
        if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === "function") {
          try {
            const permission = await DeviceMotionEvent.requestPermission();
            if (permission === "granted") {
              splash.style.display = "none";
            } else {
              alert("Permesso negato. Questa esperienza richiede l’uso dei sensori di movimento.");
            }
          } catch (err) {
            console.error("Errore permessi sensori:", err);
            alert("Si è verificato un errore. Controlla le impostazioni del tuo dispositivo.");
          }
        } else {
          splash.style.display = "none";
        }
      });

      window.addEventListener("load", () => {
        if (!("DeviceMotionEvent" in window)) {
          splash.style.display = "none";
        }
      });

      // Rotazione continua
      AFRAME.registerComponent("constant-rotation", {
        schema: { speed: { type: "number", default: 30 } },
        tick: function (time, timeDelta) {
          const r = this.el.object3D.rotation;
          const degToRad =
            (THREE.MathUtils && THREE.MathUtils.degToRad) ? THREE.MathUtils.degToRad : THREE.Math.degToRad;
          const delta = degToRad(this.data.speed) * (timeDelta / 1000);
          r.y += delta;
        },
      });

      // Interazione mouse+touch (stabilizzata: pinch usa scala iniziale, non moltiplica ogni frame)
      AFRAME.registerComponent("interaction-handler", {
        init: function () {
          this.isMouseDown = false;
          this.previousMousePosition = { x: 0, y: 0 };
          this.zoomStep = 0.12;
          this.rightClickActive = false;

          this.previousTouch = null;
          this.initialDistance = null;
          this.initialScaleAtPinch = null;
          this.touchSensitivity = 0.006;

          this._onMouseDown = this.onMouseDown.bind(this);
          this._onMouseUp = this.onMouseUp.bind(this);
          this._onMouseMove = this.onMouseMove.bind(this);
          this._onMouseWheel = this.onMouseWheel.bind(this);
          this._onContextMenu = (e) => e.preventDefault();

          this._onTouchStart = this.onTouchStart.bind(this);
          this._onTouchMove = this.onTouchMove.bind(this);
          this._onTouchEnd = this.onTouchEnd.bind(this);

          const sceneEl = this.el.sceneEl;

          const setupCanvasListeners = () => {
            const canvas = sceneEl.canvas;
            if (!canvas) return;

            canvas.addEventListener("mousedown", this._onMouseDown);
            canvas.addEventListener("mouseup", this._onMouseUp);
            canvas.addEventListener("mousemove", this._onMouseMove);
            canvas.addEventListener("wheel", this._onMouseWheel, { passive: false });
            canvas.addEventListener("contextmenu", this._onContextMenu);

            sceneEl.addEventListener("touchstart", this._onTouchStart, { passive: false });
            sceneEl.addEventListener("touchmove", this._onTouchMove, { passive: false });
            sceneEl.addEventListener("touchend", this._onTouchEnd, { passive: true });
          };

          if (sceneEl.canvas) {
            setupCanvasListeners();
          } else {
            sceneEl.addEventListener("render-target-loaded", setupCanvasListeners, { once: true });
          }
        },

        remove: function () {
          const sceneEl = this.el.sceneEl;
          const canvas = sceneEl.canvas;

          if (canvas) {
            canvas.removeEventListener("mousedown", this._onMouseDown);
            canvas.removeEventListener("mouseup", this._onMouseUp);
            canvas.removeEventListener("mousemove", this._onMouseMove);
            canvas.removeEventListener("wheel", this._onMouseWheel);
            canvas.removeEventListener("contextmenu", this._onContextMenu);
          }

          sceneEl.removeEventListener("touchstart", this._onTouchStart);
          sceneEl.removeEventListener("touchmove", this._onTouchMove);
          sceneEl.removeEventListener("touchend", this._onTouchEnd);
        },

        clampScale: function (s) {
          const minScale = 0.005;
          const maxScale = 13;
          return Math.max(minScale, Math.min(maxScale, s));
        },

        // Mouse
        onMouseDown: function (event) {
          this.isMouseDown = true;
          this.rightClickActive = event.button === 2;
          this.previousMousePosition.x = event.clientX;
          this.previousMousePosition.y = event.clientY;
        },

        onMouseUp: function () {
          this.isMouseDown = false;
        },

        onMouseMove: function (event) {
          if (!this.isMouseDown) return;

          const deltaX = event.clientX - this.previousMousePosition.x;
          const deltaY = event.clientY - this.previousMousePosition.y;
          const o = this.el.object3D;

          if (this.rightClickActive) {
            o.position.x = Math.max(-1.8, Math.min(1.8, o.position.x + deltaX * 0.004));
            o.position.y = Math.max(-1.5, Math.min(1.5, o.position.y - deltaY * 0.004));
          } else {
            o.rotation.y += deltaX * 0.005;
            o.rotation.x += deltaY * 0.005;
          }

          this.previousMousePosition.x = event.clientX;
          this.previousMousePosition.y = event.clientY;
        },

        onMouseWheel: function (event) {
          event.preventDefault();
          const o = this.el.object3D;

          const direction = Math.sign(event.deltaY); // +1 = zoom out, -1 = zoom in
          const factor = 1 - direction * this.zoomStep;

          const current = o.scale.x;
          const next = this.clampScale(current * factor);

          o.scale.setScalar(next);
        },

        // Touch
        onTouchStart: function (event) {
          const o = this.el.object3D;

          if (event.touches.length === 1) {
            this.previousTouch = {
              x: event.touches[0].clientX,
              y: event.touches[0].clientY,
            };
          } else if (event.touches.length === 2) {
            this.previousTouch = this.getMidpoint(event.touches);
            this.initialDistance = this.getDistance(event.touches);
            this.initialScaleAtPinch = o.scale.x; // scala all’inizio del pinch
          }
        },

        onTouchMove: function (event) {
          event.preventDefault();
          const o = this.el.object3D;

          if (event.touches.length === 1 && this.previousTouch) {
            const currentTouch = {
              x: event.touches[0].clientX,
              y: event.touches[0].clientY,
            };

            const dx = (currentTouch.x - this.previousTouch.x) * this.touchSensitivity;
            const dy = (currentTouch.y - this.previousTouch.y) * this.touchSensitivity;

            o.rotation.y += dx;
            o.rotation.x += dy;

            this.previousTouch = currentTouch;
          } else if (event.touches.length === 2 && this.previousTouch && this.initialDistance && this.initialScaleAtPinch) {
            const currentMidpoint = this.getMidpoint(event.touches);
            const currentDistance = this.getDistance(event.touches);

            const dx = (currentMidpoint.x - this.previousTouch.x) * this.touchSensitivity;
            const dy = (currentMidpoint.y - this.previousTouch.y) * this.touchSensitivity;

            // Traslazione due dita
            o.position.x = Math.max(-1.8, Math.min(1.8, o.position.x + dx));
            o.position.y = Math.max(-1.5, Math.min(1.5, o.position.y - dy));

            // Pinch zoom: scala = scala_iniziale * (d / d0)
            const scaleFactor = currentDistance / this.initialDistance;
            const next = this.clampScale(this.initialScaleAtPinch * scaleFactor);
            o.scale.setScalar(next);

            this.previousTouch = currentMidpoint;
          }
        },

        onTouchEnd: function () {
          this.previousTouch = null;
          this.initialDistance = null;
          this.initialScaleAtPinch = null;
        },

        // Utility
        getMidpoint: function (touches) {
          return {
            x: (touches[0].clientX + touches[1].clientX) / 2,
            y: (touches[0].clientY + touches[1].clientY) / 2,
          };
        },

        getDistance: function (touches) {
          const dx = touches[0].clientX - touches[1].clientX;
          const dy = touches[0].clientY - touches[1].clientY;
          return Math.sqrt(dx * dx + dy * dy);
        },
      });
    </script>
  </body>
</html>
