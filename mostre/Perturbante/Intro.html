<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Il Perturbante - Biblioteca Angelica</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #000; --fg: #fff; --muted: #bbb; --accent: #1e88e5; --card: #111; --border: #333;
    }
    html, body { margin:0; padding:0; height:100%; background:var(--bg); color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .stage { position: fixed; inset: 0; display: grid; place-items: center; background: var(--bg); }
    #slide { max-width: 100vw; max-height: calc(100vh - 84px); object-fit: contain; image-rendering: auto; }

    .controls {
      position: fixed; left: 0; right: 0; bottom: 0;
      background: linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.65) 35%, rgba(0,0,0,.85) 100%);
      padding: 10px 14px 12px; display: grid; gap: 8px; box-sizing: border-box;
    }
    .row { display: flex; align-items: center; gap: 12px; }
    .btn {
      display:inline-flex; align-items:center; justify-content:center; min-width:110px;
      padding:10px 14px; border-radius:10px; border:1px solid var(--border);
      background:var(--card); color:var(--fg); font-weight:600; cursor:pointer; user-select:none;
    }
    .btn:active { transform: translateY(1px); }
    .time { font-variant-numeric: tabular-nums; min-width: 60px; text-align: center; color: var(--muted); }
    .slider { flex:1; display:flex; align-items:center; gap:10px; }
    input[type="range"] {
      -webkit-appearance:none; appearance:none; width:100%; height:6px; background:#444; border-radius:999px; outline:none;
    }
    input[type="range"]::-webkit-slider-thumb, input[type="range"]::-moz-range-thumb {
      width:18px; height:18px; border-radius:50%; background:var(--accent); border:none; cursor:pointer;
      box-shadow:0 0 0 4px rgba(30,136,229,0.25);
    }
    .overlay {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,0.75); backdrop-filter: blur(2px);
    }
    .card {
      background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 18px 20px; max-width: 90vw;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5); text-align: center;
    }
    .hint { opacity: 0.85; font-size: 0.95rem; margin-top: 6px; }
  </style>
</head>
<body>
  <!-- Audio -->
  <audio id="audio" src="Intro_IT.mp3" preload="auto" autoplay playsinline></audio>

  <!-- Immagine -->
  <div class="stage">
    <img id="slide" alt="slideshow sincronizzato all'audio" />
  </div>

  <!-- Controlli -->
  <div class="controls" id="controls" aria-label="controlli riproduzione">
    <div class="row">
      <button id="playPause" class="btn" type="button">⏸ Pausa</button>
    </div>
    <div class="row slider">
      <span id="cur" class="time">0:00</span>
      <input id="seek" type="range" min="0" max="0" step="0.01" value="0" aria-label="posizione" />
      <span id="dur" class="time">0:00</span>
    </div>
  </div>

  <!-- Overlay autoplay -->
  <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-label="Autoplay bloccato">
    <div class="card">
      <div style="font-size:1.1rem; font-weight:700; margin-bottom:6px;">Autoplay bloccato</div>
      <div>Clicca <em>Avvia</em> per riprodurre l'audio e far partire la sequenza di immagini.</div>
      <button id="startBtn" class="btn" type="button">▶︎ Avvia</button>
      <div class="hint">Suggerimento: consenti l'autoplay audio nelle preferenze del browser.</div>
    </div>
  </div>

  <script>
    (function() {
      const audio   = document.getElementById('audio');
      const slide   = document.getElementById('slide');
      const overlay = document.getElementById('overlay');
      const startBtn= document.getElementById('startBtn');

      const playPause = document.getElementById('playPause');
      const seek      = document.getElementById('seek');
      const tCur      = document.getElementById('cur');
      const tDur      = document.getElementById('dur');

      // =======================
      // EDITA QUI I TUOI TEMPI
      // =======================
      // Inserisci i tempi (in secondi) ai quali vuoi che inizi ogni immagine.
      // Lunghezza deve coincidere col numero di immagini.
      // Se lasci vuoto [], i tempi verranno creati in modo equidistante sull'intera durata dell'audio.
      let CUE_POINTS = [0, 18.0, 21.0, 24.0, 36.0, 45.0, 55.0, 67.0, 80.0, 92.0, 105, 110, 120]; // es.: [0, 5.0, 12.3, 18.0, 26.5, 33.0]

      // Config immagini (01.png, 02.png, ...)
      const baseName = '';       // prefisso opzionale, es. 'img-' -> 'img-01.png'
      const extension = '.png';
      const paddingDigits = 2;
      const maxProbe = 999;

      let images = [];
      let cues = [];   // cue points effettivi usati
      let started = false;
      let duration = 0;
      let lastIndex = -1;
      let rafId = 0;
      let isUserScrubbing = false;

      function fmtTime(s) {
        if (!isFinite(s)) return '0:00';
        s = Math.max(0, Math.floor(s));
        const m = Math.floor(s / 60);
        const ss = String(s % 60).padStart(2, '0');
        return `${m}:${ss}`;
      }

      function loadImage(name) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error('not found: ' + name));
          img.src = name;
        });
      }

      async function discoverImages() {
        const arr = [];
        for (let i = 0; i <= maxProbe; i++) {
          const n = String(i).padStart(paddingDigits, '0');
          const name = baseName + n + extension;
          try {
            const img = await loadImage(name);
            arr.push(img);
          } catch {
            break;
          }
        }
        return arr;
      }

      function buildEquidistantCues(N, dur) {
        if (!N || dur <= 0) return [];
        const out = new Array(N);
        for (let i = 0; i < N; i++) out[i] = (i * dur) / N;
        return out;
      }

      function normalizeCues(userCues, N, dur) {
        // Se non specificati o di lunghezza errata, crea equidistanti
        if (!Array.isArray(userCues) || userCues.length !== N) {
          return buildEquidistantCues(N, dur);
        }
        // Copia e ripulisci
        const c = userCues.map(x => Math.max(0, Math.min(dur, Number(x) || 0)));
        // Ordina crescente e imposta l'ultimo <= durata
        c.sort((a,b) => a - b);
        if (c[0] > 0) c[0] = 0;             // prima immagine parte da 0
        if (c[c.length-1] > dur) c[c.length-1] = dur - 0.001;
        return c;
      }

      function indexFromTime(t) {
        // restituisce l'indice dell'immagine i tale che cues[i] <= t < cues[i+1]
        // ultimo indice se t oltre l'ultimo cue
        const N = images.length;
        if (N === 0) return -1;
        if (t <= cues[0]) return 0;
        for (let i = N - 1; i >= 0; i--) {
          if (t >= cues[i]) return i;
        }
        return 0;
      }

      function showIndex(idx) {
        if (idx < 0 || idx >= images.length) return;
        if (idx !== lastIndex) {
          slide.src = images[idx].src;
          lastIndex = idx;
        }
      }

      function updateUI() {
        if (!isUserScrubbing) seek.value = String(audio.currentTime);
        tCur.textContent = fmtTime(audio.currentTime);
      }

      function tick() {
        const idx = indexFromTime(audio.currentTime);
        showIndex(idx);
        updateUI();
        if (!audio.ended) {
          rafId = requestAnimationFrame(tick);
        } else {
          showIndex(images.length - 1);
          playPause.textContent = '▶︎ Riprendi';
        }
      }

      function startIfReady() {
        if (started) return;
        if (!images.length || !isFinite(audio.duration) || audio.duration <= 0) return;
        duration = audio.duration;
        seek.max = String(duration);
        tDur.textContent = fmtTime(duration);

        // Normalizza cue points
        cues = normalizeCues(CUE_POINTS, images.length, duration);

        started = true;
        showIndex(0);
        cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(tick);
      }

      function setPlayStateUI() {
        playPause.textContent = audio.paused ? '▶︎ Riprendi' : '⏸ Pausa';
      }

      async function tryAutoplay() {
        try {
          await audio.play();
          overlay.style.display = 'none';
          setPlayStateUI();
          startIfReady();
        } catch {
          overlay.style.display = 'flex';
          setPlayStateUI();
        }
      }

      // Controlli
      playPause.addEventListener('click', async () => {
        if (audio.paused) {
          try { await audio.play(); } catch {}
        } else {
          audio.pause();
        }
        setPlayStateUI();
        if (!audio.paused) {
          cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(tick);
        }
      });

      seek.addEventListener('input', () => {
        isUserScrubbing = true;
        const t = Number(seek.value);
        if (isFinite(t)) {
          audio.currentTime = Math.min(duration || 0, Math.max(0, t));
          showIndex(indexFromTime(audio.currentTime));
          tCur.textContent = fmtTime(audio.currentTime);
        }
      });
      ['change','pointerup','mouseup','touchend','keyup'].forEach(evt => {
        seek.addEventListener(evt, () => {
          isUserScrubbing = false;
          if (!audio.paused) {
            cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(tick);
          } else {
            updateUI();
          }
        }, { passive: true });
      });

      startBtn?.addEventListener('click', async () => {
        try { await audio.play(); overlay.style.display = 'none'; } catch (e) { console.error(e); }
        setPlayStateUI(); startIfReady();
      });

      // Init
      document.addEventListener('DOMContentLoaded', async () => {
        images = await discoverImages();
        if (!images.length) {
          const ph = new Blob(['data:image/svg+xml;utf8,' + encodeURIComponent(
            `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 600">
              <rect width="100%" height="100%" fill="#111"/>
              <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle"
                    fill="#fff" font-family="sans-serif" font-size="28">
                Nessuna immagine trovata (attese 01.png, 02.png, …)
              </text></svg>`)], { type: 'image/svg+xml' });
          slide.src = URL.createObjectURL(ph);
        } else {
          slide.src = images[0].src;
        }

        const onMeta = () => {
          duration = audio.duration || 0;
          seek.max = String(duration);
          tDur.textContent = fmtTime(duration);
          setPlayStateUI();
          startIfReady();
        };
        if (audio.readyState >= 1) onMeta();
        audio.addEventListener('loadedmetadata', onMeta, { once: true });

        tryAutoplay();

        ['click','touchstart','keydown'].forEach(evt => {
          window.addEventListener(evt, () => { if (audio.paused) tryAutoplay(); }, { passive: true, once: true });
        });

        audio.addEventListener('timeupdate', () => {
          if (!started) return;
          if (!isUserScrubbing) {
            seek.value = String(audio.currentTime);
            tCur.textContent = fmtTime(audio.currentTime);
          }
        });
        audio.addEventListener('play',  () => { setPlayStateUI(); cancelAnimationFrame(rafId); rafId = requestAnimationFrame(tick); });
        audio.addEventListener('pause', () => setPlayStateUI());
        audio.addEventListener('ended', () => {
          setPlayStateUI(); showIndex(images.length - 1); seek.value = String(duration); tCur.textContent = fmtTime(duration);
        });
      });
    })();
  </script>
</body>
</html>
